# -*- coding: utf-8 -*-
"""trabalhoelementosfinitos1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1p_DyLwROo4z6MoO7_SGqy9J-koziT-G2
"""

import numpy as np
import matplotlib.pyplot as plt
from sympy import Matrix, init_printing

init_printing()

"""Declarando as valores que nos foram dados:

"""

#declarando respectivamente tudo que est√° acima
T_inf = 293.15
L = 0.025
k = 35
U = 67967200
rho = 8618
h_barra = 0.25 * (10**5)
c = 460
euler = 2.718281828459045235360287  # nao foi definido no problema mas estou fazendo por
                                # conta pr√≥pria por conveniencia caso precise

"""Definindo a malha, n√∫mero de elementos, L global , n√≥s, n√∫mero de equa√ß√µes e etc...

"""

coord = [
        [0,     0],
        [0.005, 0],
        [0.01,  0],
        [0.015, 0],
        [0.02,  0],
        [0.025, 0],

        [0,     0.05],
        [0.005, 0.05],
        [0.01,  0.05],
        [0.015, 0.05],
        [0.02,  0.05],
        [0.025, 0.05],
]

LG = np.array([
     [1 ,  2 ,  3 ,   4 ,  5 ],
     [2 ,  3 ,  4 ,   5 ,  6 ],
     [8 ,  9 , 10 ,  11 , 12 ],
     [7 ,  8 ,  9 ,  10 , 11 ]
     ])

EQ = [1, 2, 3, 4, 5, 0, 6, 7, 8, 9, 10, 0]

Neq = max(EQ)  # n√∫mero de equa√ß√µes
Nel = 5  # n√∫mero de elementos
Nnos = len(EQ) # n√∫mero de n√≥s

# Inicializando as matrizes que vamos usar.
K = np.zeros((Neq, Neq))
F = np.zeros(Neq)

"""Daqui para frente o nosso problema est√° resumido em montar a matriz K e F local e fazer suas respectivas liga√ß√µes com a matriz global.

Mas primeiramente precisamos definir nossas fun√ß√µes de interpola√ß√£o j√° vistas em sala de aula e suas respectivas derivadas , tanto em rela√ß√£o a ùúÇ quanto em rela√ß√£o a xi .
"""

def Phi_1(xi, eta): return ((1 - xi)*(1 - eta)) / 4
def Phi_2(xi, eta): return ((1 + xi)*(1 - eta)) / 4
def Phi_3(xi, eta): return ((1 + xi)*(1 + eta)) / 4
def Phi_4(xi, eta): return ((1 - xi)*(1 + eta)) / 4

def dPhi1_dxi(xi, eta): return (-(1 - eta)) / 4
def dPhi1_deta(xi, eta): return (-(1 - xi)) / 4

def dPhi2_dxi(xi, eta): return (1 - eta) / 4
def dPhi2_deta(xi, eta): return (-(1 + xi)) / 4

def dPhi3_dxi(xi, eta): return (1 + eta) / 4
def dPhi3_deta(xi, eta): return (1 + xi) / 4

def dPhi4_dxi(xi, eta): return (-(1 + eta)) / 4
def dPhi4_deta(xi, eta): return (1 - xi) / 4

"""E tamb√©m temos que definir nosso jacobiano:"""

# sabendo que jacobiano --> J = D*y
def jacobiano(xi, eta, coords):
    D = np.zeros((2,4))
    D = [
        [dPhi1_dxi(xi, eta) , dPhi2_dxi(xi, eta) , dPhi3_dxi(xi, eta) , dPhi4_dxi(xi, eta) ],
        [dPhi1_deta(xi, eta), dPhi2_deta(xi, eta), dPhi3_deta(xi, eta), dPhi4_deta(xi, eta)]
        ]
    J = np.dot(D,coords)
    return D, J

"""Vamos usar agora nosso conhecimento da rela√ß√£o da matriz global com a local para achar as coordenadas locais do nosso elemento finito."""

def coord_elemento(e):
    coord_local = np.zeros((4, 2))
    for i in range(4):
        coord_local[i, :] = coord[LG[i][e]-1];
    return coord_local

"""Agora abaixo, iremos criar algumas ferramentas √∫teis para n√≥s como Q e os items a e B que nos foram das no enunciado do problema mas agora em formato de c√≥digo python, e feito isso, iremos montar nossa matriz $ K^e 
 $.
"""

Q = np.matrix([[1, 0], [0, 1]])

B = (h_barra*L)/k 
a = k/(rho*c)

Q =  Q*a

def K_local(e):
    PG = [-0.5773502691, 0.5773502691]  # pontos de Gauss
    w = [1, 1]                          # pesos
    N_int = len(PG)                     # numero de pontos em cada direcao
    coord_local = coord_elemento(e)

    K_e = np.zeros((4, 4), dtype = object)
    for a in range(N_int): 
        for b in range(N_int):
            D, j = jacobiano(PG[a], PG[b], coord_local)
            det_J = np.linalg.det(j)
            if det_J <= 0:
                print("Determinante negativo!")
                exit()

            B = np.dot(np.linalg.pinv(j),D)
            x = np.dot(B.transpose(),Q)
            x = np.dot(x,B)
            K_e += x * det_J * w[a] * w[b]  # integral de (‚àáœÜ·µÄ)Q(‚àáœÜ) dŒ©

    return K_e

"""Mas, com o que foi feito acima podemos j√° montar a K global tamb√©m!"""

def K_global(K, K_e, e):
    for a in range(4):
        for b in range(4):
            i = EQ[LG[a][e]-1]
            j = EQ[LG[b][e]-1]
            if (i != 0) and (j != 0):   # iremos pular 
                K[i-1][j-1] += K_e[a][b]
    return K

"""Agora partiremos para o c√°lculo da F local e de maneira an√°loga vamos achar a F global tamb√©m!"""

from mpmath.ctx_mp_python import from_man_exp
# tratando condi√ß√£o de contorno
P = np.zeros(Nnos)
P[5] = T_inf
P[11] = T_inf

p = np.zeros(4);

# funcao que vamos usar depois, em formato de funcao lamba 

f = lambda x : U / (rho*c)

def F_prescrito(K_e, e):
  p = P[LG[0:4, e]-1]
  F_p = np.dot(K_e, p)
  return F_p

def F_local(K_e, e):
    PG = [-0.5773502691, 0.5773502691]  # pontos de Gauss
    w = [1, 1]                          # pesos
    N_int = len(PG)                     # numero de pontos em cada direcao
    coord_local = coord_elemento(e)
    M = np.zeros((4,4), dtype=object)
    for a in range (N_int):
        for b in range(N_int):
            do_nothing , J = jacobiano(PG[a], PG[b], coord_local)
            det_J = np.linalg.det(J)
            if det_J <= 0:
                print("Determinante negativo!")
                exit()
            
            Phi = [Phi_1(PG[a], PG[b]), Phi_2(PG[a], PG[b]), Phi_3(PG[a], PG[b]), Phi_4(PG[a], PG[b])]
            W = w[a]*w[b]*det_J
            for m in range(4):
                for n in range(4):
                    M[m][n] += Phi[m]*Phi[n]*W

    f_e = np.zeros(4)
    for a in range(4):
      for j in range(2):
        f_e[a] = f(coord_local[a][j])

    f_e = np.dot(M,f_e)

    return f_e - F_prescrito(K_e, e)

    
def F_global(F, F_e, e):
    for a in range(4):
        i = EQ[LG[a][e]-1]
        if i != 0:
            F[i-1] = F[i-1] + F_e[a]
        
    return F

"""Agora com todar ferramentas prontas, n√≥s vamos fazer um elemento finito para cada n√∫mero de elementos que j√° descobrimos l√° encima e chamamos carinhosamente de $N_{el}$."""

for e in range(Nel):
  K_e = K_local(e)
  K_global(K, K_e, e)
  F_e = F_local(K_e, e)
  F_global(F, F_e, e)

"""E agora comparamos as solu√ß√µes:"""

print("K")
print(K)
print("F")
print(F)

solucao_numerica = np.linalg.solve(K,F)

print(solucao_numerica[0:4])

solucao_analitica = []
xs = np.arange(0, 0.02, 0.005)
t = lambda x : T_inf + (U*L**2)/(2*k)*(1 - (x/L)**2)
for x in xs:
  solucao_analitica.append(t(x))

print(solucao_analitica)

print("\nA solu√ß√£o anal√≠tica √©:\n")
print(solucao_analitica)
print("\nA solu√ß√£o num√©rica √©:\n")
print(solucao_numerica)

